# API Gateway Proxy統合採用後の将来的な対策

## 背景

2025年10月21日時点で、API Gateway REST APIをProxy統合（`{proxy+}`）に変更しました。
これにより、Terraformの設定が大幅に簡略化され、新しいエンドポイント追加時にインフラ変更が不要になりました。

ただし、プロダクトが成長して以下のような要件が出てきた場合は、追加の実装が必要になります。

## 将来必要になる可能性のある対策

### 1. エンドポイントごとの詳細なメトリクス

**現状:** すべてのエンドポイントが `/{proxy+}` として集約される

**必要になるケース:**
- どのエンドポイントが遅いか分析したい
- エンドポイントごとのアクセス数を可視化したい
- SLAをエンドポイントごとに設定したい

**対策A: CloudWatch Logs Insightsで分析**

Lambda側で構造化ログを出力：
```python
# lambda/puzzle-register/index.py
logger.info(
    "Request processed",
    extra={
        "endpoint": path,              # "/users/{userId}/puzzles"
        "method": http_method,         # "GET"
        "status_code": status_code,
        "duration_ms": duration,
        "user_id": user_id
    }
)
```

CloudWatch Logs Insightsクエリ例：
```
# エンドポイントごとのリクエスト数
fields @timestamp, endpoint
| filter endpoint = "/users/{userId}/puzzles"
| stats count() by bin(5m)

# エンドポイントごとの平均レスポンスタイム
fields endpoint, duration_ms
| stats avg(duration_ms), max(duration_ms), min(duration_ms) by endpoint
```

**対策B: カスタムメトリクスをCloudWatchに送信**

```python
import boto3
from datetime import datetime

cloudwatch = boto3.client('cloudwatch')

def send_custom_metric(endpoint: str, method: str, duration_ms: float, status_code: int):
    """エンドポイントごとのカスタムメトリクスを送信"""
    cloudwatch.put_metric_data(
        Namespace='JigsawPuzzle/API',
        MetricData=[
            {
                'MetricName': 'RequestDuration',
                'Dimensions': [
                    {'Name': 'Endpoint', 'Value': endpoint},
                    {'Name': 'Method', 'Value': method}
                ],
                'Value': duration_ms,
                'Unit': 'Milliseconds',
                'Timestamp': datetime.utcnow()
            },
            {
                'MetricName': 'RequestCount',
                'Dimensions': [
                    {'Name': 'Endpoint', 'Value': endpoint},
                    {'Name': 'StatusCode', 'Value': str(status_code)}
                ],
                'Value': 1.0,
                'Unit': 'Count',
                'Timestamp': datetime.utcnow()
            }
        ]
    )

# 使用例
def handler(event, context):
    start_time = time.time()

    # 処理...
    response = handle_request(event, context)

    duration_ms = (time.time() - start_time) * 1000
    send_custom_metric(
        endpoint=event['path'],
        method=event['httpMethod'],
        duration_ms=duration_ms,
        status_code=response['statusCode']
    )

    return response
```

CloudWatchダッシュボードで可視化：
- Terraformで自動作成可能
- エンドポイントごとのグラフを表示

**対策C: APMツールの導入（推奨）**

DatadogやNew Relicなどの専用ツール：

```python
# DatadogのLambda統合
# requirements.txtに追加: datadog-lambda

from datadog_lambda.wrapper import datadog_lambda_wrapper
from datadog_lambda.metric import lambda_metric

@datadog_lambda_wrapper
def handler(event, context):
    # 自動的にトレース・メトリクスを収集
    path = event['path']

    lambda_metric(
        "api.request.count",
        1,
        tags=[f"endpoint:{path}", f"method:{event['httpMethod']}"]
    )

    return handle_request(event, context)
```

メリット：
- エンドポイントごとの詳細な分析が自動化
- アラート設定が簡単
- トレース機能で処理の流れが可視化される

コスト：月額$15〜（スタートアップは無料枠あり）

---

### 2. エンドポイントごとのレート制限

**現状:** API Gateway全体で同じレート制限

**必要になるケース:**
- `/upload` は10 req/sに制限したい
- `/list` は100 req/sまで許可したい
- 無料ユーザーと有料ユーザーで制限を変えたい

**対策A: DynamoDBでレート制限管理**

```python
# backend/app/middleware/rate_limit.py
import boto3
from datetime import datetime
from typing import Optional

dynamodb = boto3.resource('dynamodb')
rate_limit_table = dynamodb.Table('api-rate-limits')

# エンドポイントごとのレート制限設定
RATE_LIMITS = {
    "/puzzles": {"limit": 100, "window": 60},           # 100 req/min
    "/puzzles/{id}/upload": {"limit": 10, "window": 60}, # 10 req/min
    "/users/{userId}/puzzles": {"limit": 200, "window": 60}
}

def check_rate_limit(user_id: str, endpoint: str) -> Optional[dict]:
    """
    レート制限チェック

    Returns:
        None: 制限内
        dict: 制限超過時のエラー情報
    """
    # エンドポイントパターンマッチング
    config = None
    for pattern, limit_config in RATE_LIMITS.items():
        if pattern in endpoint:
            config = limit_config
            break

    if not config:
        return None  # レート制限なし

    key = f"{user_id}:{endpoint}"
    now = int(datetime.now().timestamp())

    try:
        response = rate_limit_table.get_item(Key={'key': key})

        if 'Item' in response:
            count = response['Item']['count']
            timestamp = response['Item']['timestamp']

            # ウィンドウ内かチェック
            if now - timestamp < config['window']:
                if count >= config['limit']:
                    return {
                        'error': 'Rate limit exceeded',
                        'retry_after': config['window'] - (now - timestamp)
                    }
                count += 1
            else:
                # ウィンドウ期限切れ、リセット
                count = 1
                timestamp = now
        else:
            count = 1
            timestamp = now

        # カウント更新
        rate_limit_table.put_item(Item={
            'key': key,
            'count': count,
            'timestamp': timestamp,
            'ttl': now + config['window']
        })

        return None

    except Exception as e:
        # レート制限チェック失敗時は通過させる（可用性優先）
        logger.error(f"Rate limit check failed: {e}")
        return None

# lambda/puzzle-register/index.pyで使用
def handler(event, context):
    user_id = extract_user_id(event)
    endpoint = event['path']

    # レート制限チェック
    rate_limit_error = check_rate_limit(user_id, endpoint)
    if rate_limit_error:
        return create_response(event, 429, rate_limit_error)

    # 通常処理続行...
```

DynamoDBテーブル定義（Terraform）：
```hcl
resource "aws_dynamodb_table" "rate_limits" {
  name         = "${var.project_name}-${var.environment}-rate-limits"
  billing_mode = "PAY_PER_REQUEST"
  hash_key     = "key"

  attribute {
    name = "key"
    type = "S"
  }

  ttl {
    attribute_name = "ttl"
    enabled        = true
  }

  tags = var.common_tags
}
```

**対策B: ElastiCache (Redis)を使用（高速化）**

より高速なレート制限が必要な場合：

```python
import redis
from functools import wraps

r = redis.Redis(
    host=os.environ['REDIS_ENDPOINT'],
    port=6379,
    decode_responses=True
)

def rate_limit(limit: int, window: int):
    """デコレーターとして使用"""
    def decorator(func):
        @wraps(func)
        def wrapper(event, context):
            user_id = extract_user_id(event)
            endpoint = event['path']
            key = f"rate_limit:{user_id}:{endpoint}"

            current = r.incr(key)
            if current == 1:
                r.expire(key, window)

            if current > limit:
                return {
                    'statusCode': 429,
                    'body': json.dumps({'error': 'Rate limit exceeded'})
                }

            return func(event, context)
        return wrapper
    return decorator

# 使用例
@rate_limit(limit=10, window=60)
def handle_upload(event, context):
    ...
```

---

### 3. エンドポイントごとの認証・認可制御

**現状:** API Gateway全体で同じ認証設定

**必要になるケース:**
- `/public/` 配下は認証不要
- `/admin/` 配下は管理者のみ
- `/users/{userId}/` は本人または管理者のみ

**対策: Lambda内で認可（Authorization）制御**

```python
# backend/app/core/auth.py
from functools import wraps
from typing import List, Optional

def extract_user_from_event(event: dict) -> dict:
    """
    Cognitoオーソライザーから取得したユーザー情報を抽出

    Returns:
        {
            'user_id': 'uuid',
            'email': 'user@example.com',
            'role': 'admin' or 'user'
        }
    """
    try:
        claims = event['requestContext']['authorizer']['claims']
        return {
            'user_id': claims['sub'],
            'email': claims['email'],
            'role': claims.get('custom:role', 'user')
        }
    except (KeyError, TypeError):
        return None

def require_auth(roles: Optional[List[str]] = None):
    """
    認証・認可チェックデコレーター

    Args:
        roles: 許可するロールのリスト。Noneなら認証のみチェック
    """
    def decorator(func):
        @wraps(func)
        def wrapper(event, context):
            user = extract_user_from_event(event)

            # 認証チェック
            if not user:
                return {
                    'statusCode': 401,
                    'body': json.dumps({'error': 'Unauthorized'})
                }

            # 認可チェック
            if roles and user['role'] not in roles:
                return {
                    'statusCode': 403,
                    'body': json.dumps({'error': 'Forbidden'})
                }

            # イベントにユーザー情報を追加
            event['user'] = user
            return func(event, context)
        return wrapper
    return decorator

def require_self_or_admin(user_id_param: str = 'userId'):
    """
    本人または管理者のみアクセス可能

    Args:
        user_id_param: URLパスから取得するユーザーIDのパラメータ名
    """
    def decorator(func):
        @wraps(func)
        def wrapper(event, context):
            user = extract_user_from_event(event)

            if not user:
                return {'statusCode': 401, 'body': json.dumps({'error': 'Unauthorized'})}

            # URLパスからuserIdを取得
            path = event['path']
            path_parts = path.split('/')

            # /users/{userId}/puzzles の形式を想定
            if len(path_parts) >= 3 and path_parts[1] == 'users':
                target_user_id = path_parts[2]

                # 本人または管理者のみ許可
                if user['user_id'] != target_user_id and user['role'] != 'admin':
                    return {'statusCode': 403, 'body': json.dumps({'error': 'Forbidden'})}

            event['user'] = user
            return func(event, context)
        return wrapper
    return decorator
```

Lambda handlerでの使用例：
```python
# lambda/puzzle-register/index.py
from app.core.auth import require_auth, require_self_or_admin

def handler(event, context):
    path = event['path']
    method = event['httpMethod']

    # ルーティング + 認可チェック
    if path.startswith('/admin/'):
        # 管理者のみ
        return require_auth(roles=['admin'])(handle_admin_request)(event, context)

    elif path.startswith('/public/'):
        # 認証不要
        return handle_public_request(event, context)

    elif '/users/' in path and path.endswith('/puzzles'):
        # 本人または管理者のみ
        return require_self_or_admin()(handle_list_puzzles)(event, context)

    elif method == 'POST' and path == '/puzzles':
        # 認証必須（全ロール）
        return require_auth()(handle_create_puzzle)(event, context)

    else:
        return create_response(event, 404, {'error': 'Not found'})

@require_self_or_admin()
def handle_list_puzzles(event, context):
    # event['user'] にユーザー情報が入っている
    user = event['user']
    logger.info(f"User {user['email']} is accessing puzzles")

    # 通常処理...
```

---

### 4. APIドキュメントの自動生成

**現状:** Proxy統合ではAPI Gatewayからドキュメント自動生成できない

**対策A: OpenAPIスキーマを手動管理**

```yaml
# docs/openapi.yaml
openapi: 3.0.0
info:
  title: Jigsaw Puzzle API
  version: 1.0.0
  description: ジグソーパズル支援システムAPI

servers:
  - url: https://hbwku63803.execute-api.ap-northeast-1.amazonaws.com/dev
    description: Development server

paths:
  /puzzles:
    post:
      summary: パズルを作成
      tags:
        - Puzzles
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/PuzzleCreateRequest'
      responses:
        '200':
          description: Success
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/PuzzleResponse'
        '400':
          description: Bad Request
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ErrorResponse'

  /users/{userId}/puzzles:
    get:
      summary: ユーザーのパズル一覧を取得
      tags:
        - Puzzles
      parameters:
        - name: userId
          in: path
          required: true
          schema:
            type: string
          description: ユーザーID
      responses:
        '200':
          description: Success
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/PuzzleListResponse'

components:
  schemas:
    PuzzleCreateRequest:
      type: object
      required:
        - pieceCount
        - puzzleName
      properties:
        pieceCount:
          type: integer
          enum: [100, 300, 500, 1000, 2000]
          description: ピース数
        puzzleName:
          type: string
          maxLength: 100
          description: パズル名
        userId:
          type: string
          description: ユーザーID（オプション、デフォルトは"anonymous"）

    PuzzleResponse:
      type: object
      properties:
        puzzleId:
          type: string
          format: uuid
        puzzleName:
          type: string
        pieceCount:
          type: integer
        status:
          type: string
          enum: [pending, uploaded, processing, completed]
        createdAt:
          type: string
          format: date-time

    PuzzleListResponse:
      type: object
      properties:
        userId:
          type: string
        count:
          type: integer
        puzzles:
          type: array
          items:
            $ref: '#/components/schemas/PuzzleResponse'

    ErrorResponse:
      type: object
      properties:
        error:
          type: string
        details:
          type: string
```

Swagger UIでホスティング：
```bash
# Swagger UIをS3にデプロイ
# または、Redocly/Stoplight Studioを使用
```

**対策B: Pydanticモデルから自動生成**

```python
# scripts/generate_openapi.py
from backend.app.core.schemas import PuzzleCreateRequest, PuzzleResponse
from pydantic.json_schema import models_json_schema
import json

schemas = [PuzzleCreateRequest, PuzzleResponse]
schema_json = models_json_schema([(s, 'validation') for s in schemas])

openapi = {
    "openapi": "3.0.0",
    "info": {
        "title": "Jigsaw Puzzle API",
        "version": "1.0.0"
    },
    "components": {
        "schemas": schema_json[1]['$defs']
    }
}

with open('docs/openapi.json', 'w') as f:
    json.dump(openapi, f, indent=2)
```

---

### 5. より高度な対策が必要になった場合

**ケース1: エンドポイントが100個以上に増えた**
→ マイクロサービス化を検討
- `/api/users/*` → User Service Lambda
- `/api/puzzles/*` → Puzzle Service Lambda
- `/api/analytics/*` → Analytics Service Lambda

**ケース2: 外部パートナーにAPIを公開する**
→ API Keyやクォータ管理が必要
- AWS API Gateway Usage Plansを使用
- または、個別エンドポイント定義に戻す

**ケース3: 非常に細かいレート制限が必要**
→ Kong/AWS App Meshなど専用API Gatewayを追加

**ケース4: リアルタイム性が重要**
→ WebSocket APIへの移行
- API Gateway WebSocket API
- AppSyncも検討

---

## まとめ

Proxy統合は「必要最低限でスタート、必要に応じて拡張」というアプローチに適しています。

現時点で必要なもの：
- ✅ 基本的なルーティング
- ✅ CORS対応
- ✅ 基本的な認証（Cognito）

将来追加実装が必要になるもの：
- エンドポイントごとのメトリクス → CloudWatch Logs Insights / APMツール
- エンドポイントごとのレート制限 → DynamoDB / Redis
- 細かい認可制御 → Lambda内で実装
- APIドキュメント → OpenAPI手動管理 / Pydanticから生成

**重要:** すべての対策はコードで実装できるため、Proxy統合を選んでも後から追加可能です。
